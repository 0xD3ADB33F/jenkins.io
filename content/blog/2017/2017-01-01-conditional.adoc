---
layout: post
title: "Migrating to Pipeline: Conditional BuildStep plugin"
tags:
- pipeline
- freestyle
- plugins
- conditional-build-step
author: lnewman
---

NOTE: This is a guest post by link:https://github.com/bitwiseman[Liam Newman],
Technical Evangelist at link:http://cloudbees.com[CloudBees].

The
link:https://plugins.jenkins.io/conditional-buildstep[Conditional BuildStep plugin]
is a powerful tool that has allowed Jenkins users to write Jenkins jobs with
complex conditional logic.  The plugin also includes a set of
token macros that expose a wide range of job state information on which to base
those conditions.  Implementing conditional behavior in Jenkins Pipeline is trivial,
but migrating jobs using complex conditional build steps requires a bit more care.


== Introduction

There are number of plugins, some that have been around since before Jenkins was
Jenkins, that enable users to create "pipelines" in Jenkins.

With all the new developments in Jenkins Pipeline and with Declarative Pipeline
on the horizon, it's easy forget what we did to create pipelines before Pipeline.

In particular, creating chained jobs with conditional behavior was one of the harder things to
do in Jenkins.

Basic job chaining worked well in most cases, but what about when
a pipeline needed conditional logic?

// TODO: This intro is still coming together.

The
link:https://plugins.jenkins.io/conditional-buildstep[Conditional BuildStep plugin]
addresses this need head-on.
In this post, we'll look some examples of things we might do using the
Conditional BuildStep plugin and how to implement the same behavior in
Jenkins Pipeline.



== Graphical Programming

The Conditional BuildStep plugin lets users add conditional logic to Freestyle
jobs from within the Jenkin UI.  It does this by:

* Adding two types of Conditional BuildStep ("Single" and "Multiple") -
these build steps contain one or more other build steps to be run when the configured
condition is met
* Adding a set of Condition operations -
these control whether the Conditional BuildStep execute the contained step(s)
* Leveraging the Token Macro facility -
these provide values to the Conditions for evaluation

In the example below, this project will run the shell script step when the value of the
`REQUESTED_ACTION` token equals "greeting".

image::/images/post-images/2017-01-11/freestyle-conditional-param.png[Freestyle Job Parameters, role="center"]

image::/images/post-images/2017-01-11/freestyle-conditional-config.png[Freestyle Job Conditional BuildStep, role="center"]

Here's the output when I run this project with `REQUESTED_ACTION` set to "greeting":

[source]
----
Run condition [Strings match] enabling prebuild for step [Execute shell]
Strings match run condition: string 1=[greeting], string 2=[greeting]
Run condition [Strings match] enabling perform for step [Execute shell]
[freestyle-conditional] $ /bin/sh -xe /var/folders/hp/f7yc_mwj2tq1hmbv_5n10v2c0000gn/T/hudson5963233933358491209.sh
+ echo 'Hello, bitwiseman!'
Hello, bitwiseman!
Finished: SUCCESS
----

And when I pass the value "silence":

[source]
----
Run condition [Strings match] enabling prebuild for step [Execute shell]
Strings match run condition: string 1=[greeting], string 2=[greeting]
Run condition [Strings match] enabling perform for step [Execute shell]
[freestyle-conditional] $ /bin/sh -xe /var/folders/hp/f7yc_mwj2tq1hmbv_5n10v2c0000gn/T/hudson5963233933358491209.sh
+ echo 'Hello, bitwiseman!'
Hello, bitwiseman!
Finished: SUCCESS
----

This is basic example but the conditional step can contain any regular build step available.
When combined with other plugins, it can control whether to send notifications,
gather data from other sources, wait for user feedback, or call other projects.

The Conditional BuildStep plugin does a great job of leveraging strengths of
the Jenkins UI, and freestyle jobs, and UI-based programming,
but it is also hampered by their limitations.
The Jenkins UI can be clunky and confusing at times.
Like the steps in any freestyle job the logic in these conditional steps is only
stored and viewable in Jenkins.
It is not versioned with other product or build code and can't be code reviewed.
Like any number of UI-based programming it has to make trade-offs between clarity
and flexibility: more options or clearer presentation.
There's only so much space on the screen.

== Migrating to Pipeline

// TODO: Transitional paragraph about migrating to pipeline

The Pipeline equivalent of the example above is:

[pipeline]
----
// Declarative //
pipeline {
    agent any
    parameters {
        choice(
            // choices must be newline separated
            choices: ['greeting','silence'].join('\n'),
            description: '',
            name: 'REQUESTED_ACTION')
    }

    stages {
        stage ('Speak') {
            when {
                // Only say hello if a "greeting" is requested
                expression { return params.REQUESTED_ACTION == 'greeting' }
            }
            steps {
                echo "Hello, bitwiseman!"
            }
        }
    }
}
// Script //
properties ([
    parameters ([
        choice (
            // choices must be newline separated
            choices: ['greeting','silence'].join('\n'),
            description: '',
            name : 'REQUESTED_ACTION')
    ])
])

node {
    stage ('Speak') {
        // Only say hello if a "greeting" is requested
        if (params.REQUESTED_ACTION == 'greeting') {
            echo "Hello, bitwiseman!"
        }
    }
}
----

Here's the output when I run this project with `REQUESTED_ACTION` set to "greeting":

[source]
----
[Pipeline] node
Running on osx_mbp in /Users/bitwiseman/jenkins/agents/osx_mbp/workspace/pipeline-conditional
[Pipeline] {
[Pipeline] stage
[Pipeline] { (Speak)
[Pipeline] echo
Hello, bitwiseman!
[Pipeline] }
[Pipeline] // stage
[Pipeline] }
[Pipeline] // node
[Pipeline] End of Pipeline
Finished: SUCCESS
----

When at I pass the value "silence", the only change is "Hello, bitwiseman!" is not printed.

The Pipeline code is considerably more compact than the Jenkins UI presentation.
I had to do a some web searching to find out how to had build
parameters to Pipeline
(link:https://issues.jenkins-ci.org/browse/WEBSITE-281[One more task] for our
documentation efforts).
It took several iterations to get this pipeline to work, but it was pretty quick.


=== Conditions
The previous example showed the "Strings match" condition and it's Pipeline equivalent.
Let's look at couple more interesting conditions and their pipeline equivalents.

==== Boolean condition

[QUOTE]
====
Expand the Token Macro and run the build step if it evaluates to true.

Truth is a case insensitive match of one of the following:
1 (the number one), Y, YES, T, TRUE, ON or RUN.
====

You might think that a boolean condition would be the simplest condition, but it isn't.
Since it works with string values from tokens, the Conditional BuildStep plugin offers
a number of ways to indicate true or false.
Pipeline can duplicate these, but we might consider if a simpler expression
would suffice on a case-by-case basis.

.Pipeline
[pipeline]
----
// Declarative //
when {
    // case insensitive regular expression for truthy values
    expression { return token ==~ /(?i)(Y|YES|T|TRUE|ON|RUN)/ }
}
steps {
    /* step */
}

// Script //
// case insensitive regular expression for truthy values
if (token ==~ /(?i)(Y|YES|T|TRUE|ON|RUN)/) {
    /* step */
}
----

==== Logical "OR" of conditions

[QUOTE]
====
Will run if any of the contained conditions would run.
====

This condition, along with the `AND` and `NOT` conditions, wraps other conditions.

// TODO: Image of the OR condition.


.Pipeline
[pipeline]
----
// Declarative //
when {
    // A or B
    expression { return A || B }
}
steps {
    /* step */
}

// Script //
// A or B
if (A || B) {
    /* step */
}
----

==== Condition number 3

// Add one more Condition example

=== Tokens

Tokens can be considerably more trouble than conditions. There are more of them
and they cover a much broader range of behaviors.  In the previous example,
showed one of the simpler cases, accessing a build parameter, where a token has
a  direct equivalent in Pipeline.  Many tokens do not have direct
equivalents and some provide functionality not exposed in pipeline yet.
Determining how to migrate tokens need to be done on case by case basis.

Let's look at a few examples.

// TODO: Discuss a few common tokens and their Pipeline equivalents
==== Token_1

// TODO

==== Token_2

// TODO

==== Token_3

// TODO


== Another Example

// TODO: Show a more complex example, using each of the conditions and tokens above.



== Conclusion

As I said before, the Conditional BuildStep plugin is great.
It provides a clear, easy to understand way to add conditional logic to any freestyle job.
Before Pipeline, it was one of the few plugins to do this and it remains one of the most popular plugins.
But now there's Jenkins Pipeline.
And with the upcoming releases of Declarative Pipeline and Blue Ocean, it is time to
begin looking at migrating from

This is blog post discussed how to approach migrating conditional build steps to pipeline
and showed a couple concrete examples.  Overall, I'm pleased with the results so far.
I found scenarios which could not easily be migrated to Pipeline, but even those
are just more difficult not impossible.

The next thing to do is add a section to the
link:https://jenkins.io/doc/book/[Jenkins Handbook] documenting the Pipeline
equivalent of all of the Conditions and the most commonly used Tokens.
Look for it soon!

== Links

* link:https://wiki.jenkins-ci.org/display/JENKINS/Conditional+BuildStep+Plugin[Conditional+BuildStep+Plugin]
