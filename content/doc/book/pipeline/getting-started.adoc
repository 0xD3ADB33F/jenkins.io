---
layout: section
---
:notitle:
:description:
:author:
:email: jenkinsci-users@googlegroups.com
:sectanchors:
:toc:

= Getting Started

== Pipeline Defined

Pipelines are Jenkins jobs enabled by the Pipeline (formerly called "workflow")
plugin and built with simple text scripts that use a Pipeline DSL
(domain-specific language) based on the Groovy programming language.

Pipelines leverage the power of multiple steps to execute both simple and
complex tasks according to parameters that you establish. Once created,
pipelines can build code and orchestrate the work required to drive applications
from commit to delivery.

== Preparing Jenkins to Run Pipelines

To run pipelines, you need to have a Jenkins instance that is set up with the
appropriate plugins. This requires:

* Jenkins 2.x or later (older versions back to 1.642.3 will work but are not
  recommended)
* Pipeline plugin

=== Installing Pipeline

The Pipeline plugin is installed in the same way as other Jenkins plugins.
Installing the Pipeline plugin also installs the suite of related plugins on
which it depends:

. Open Jenkins in your web browser.
. On the Manage Jenkins page for your installation, navigate to *Manage Plugins*.
. Find https://plugins.jenkins.io/workflow-aggregator[Pipeline] from the plugins listed on the Available tab (You can do this by scrolling through the plugin list or by using "Pipeline" as a term to filter results).
. Select the checkbox for Pipeline plugin.
. Select either *Install without restart* or *Download now and install after restart*.
. Restart Jenkins.


== Defining Pipeline Script

You can create pipelines in either of the following ways:

* Through script entered in the configuration page of the web interface for your Jenkins instance.
* Through a `Jenkinsfile` that you create with a text editor and then check into your project's source control repository, where it can be accessed when you select the *Pipeline Script from SCM* option while configuring the Pipeline in Jenkins.

[NOTE]
====
When you use a Jenkinsfile, it is a best practice to put #!groovy at the top of the file so that IDEs and
GitHub diffs detect the Groovy language properly.
====

== Creating a Simple Pipeline

Initial pipeline usage typically involves the following tasks:

. Downloading and installing the Pipeline plugin (Unless it is already part of your Jenkins installation)
. Creating a Pipeline of a specific type
. Configuring your Pipeline
. Controlling flow (workflow) through your Pipeline
. Scaling your Pipeline

To create a simple pipeline from the Jenkins interface, perform the following steps:

. Click *New Item* on your Jenkins home page,  enter a name for your (pipeline) job, select *Pipeline*, and click *OK*.
. In the Script text area of the configuration screen, enter your pipeline script. If you are new to pipeline creation, you might want to start by opening Snippet Generator and selecting the "Hello Word" snippet.
. Check the Use Groovy Sandbox option below the Script text area.
. Click *Save*.
. Click *Build Now* to create the pipeline.
. Click ▾ and select *Console Output* to see the output.


Pipelines are written as Groovy scripts that tell Jenkins what to do when they
are run. Relevant bits of syntax are introduced as needed, so while an
understanding of Groovy is helpful, it is not required to use Pipeline.

If you are a Jenkins administrator (in other words, authorized to approve your
own scripts), sandboxing is optional but efficient, because it lets scripts run
without approval as long as they limit themselves to operations that Jenkins
considers inherently safe.

[NOTE]
====
To use pathnames that include spaces, bracket those pathnames between escaped double quotes using \".
The extra quotation marks ensure that any spaces in pathnames are parsed properly.
====

The following example shows a successful build of a pipeline created with a
one-line script that uses the `echo` step to output the phrase, "Hello from
Pipeline":

[pipeline]
----
// Script //
node {
    echo 'Hello from Pipeline'
}
----

----
Started by user anonymous
[Pipeline] echo
Hello from Pipeline
[Pipeline] End of Pipeline
Finished: SUCCESS
----

[NOTE]
====
You can also create complex and multibranch pipelines in the script entry
area of the Jenkins configuration page, but because they contain multiple stages
and the configuration page UI provides limited scripting space, pipeline
creation is more commonly done using an editor of your choice from which scripts
can be loaded into Jenkins using the *Pipeline script from SCM* option.

====

It is a best practice to use parallel steps whenever you can, as long as you remember not to attempt so much parallel processing
that it swamps the number of available executors. For example, you can acquire a node within the parallel branches of your pipeline:

[pipeline]
----
// Script //
node {
    parallel 'integration-tests' : {
        node('mvn-3.3') {
          /* run Maven-based integration tests */
        }
    },
    'functional-tests' : {
        node('selenium') {
          /* run selenium */
        }
    }
}
----

== Creating Multibranch Pipelines

The *Multibranch Pipeline* project type enables you to configure different jobs
for different branches of the same project. In a multibranch pipeline
configuration, Jenkins automatically discovers, manages, and executes jobs
for multiple source repositories and branches. This eliminates the need for
manual job creation and management, as would otherwise be necessary
when, for example, a developer adds a new feature to an existing
product.

A multibranch pipeline project always includes a 'Jenkinsfile' in its
repository root. Jenkins automatically creates a sub-project for each branch
that it finds in a repository with a `Jenkinsfile`.

Multibranch pipelines use the same version control as the rest of your software
development process. This "pipeline as code" approach has the following
advantages:

* You can modify pipeline code without special editing permissions.
* Finding out who changed what and why no longer depends on whether developers remember to comment their code changes in configuration files.
* Version control makes the history of changes to code readily apparent.

To create a Multibranch Pipeline:

. Click New Item on your Jenkins home page, enter a name for your job, select Multibranch Pipeline, and click OK.
. Configure your SCM source (options include Git, GitHub, Mercurial, Subversion, and Bitbucket), supplying information about the owner, scan credentials, and repository in appropriate fields.
  For example, if you select Git as the branch source, you are prompted for the usual connection information, but then rather than enter a fixed refspec (Git's name for a source/destination pair), you would enter a branch name pattern (Use default settings to look for any branch).
. Configure the other multibranch pipeline options:
 * API endpoint - an alternate API endpoint to use a self-hosted GitHub Enterprise
 * Checkout credentials - alternate credentials to use when checking out the code (cloning)
 * Include branches - a regular expression to specify branches to include
 * Exclude branches - a regular expression to specify branches to exclude; note that this will takes precedence over the contents of include expressions
. Save your configuration.

Jenkins automatically scans the designated repository and creates appropriate branches.

For example (again in Git), if you started with a master branch, and then wanted
to experiment with some changes, and so did `git checkout -b newfeature` and
pushed some commits, Jenkins would automatically detect the new branch in your
repository and create a new sub-project for it. That sub-project would have its
own build history unrelated to the trunk (main line).

If you choose, you can ask for the sub-project to be automatically removed after
its branch is merged with the main line and deleted. To change your Pipeline
script—for example, to add a new Jenkins publisher step corresponding to new
reports that your `Makefile`/`pom.xml`/etc. is creating—you edit the appropriate
`Jenkinsfile`. Your Pipeline script is always synchronized with
the rest of the source code you are working on.

*Multibranch Pipeline* projects expose the name of the branch being built with
the `BRANCH_NAME` environment variable. In multibranch pipelines, the `checkout
scm` step checks out the specific commit that the `Jenkinsfile` originated, so
as to maintain branch integrity.

== Loading Pipeline Scripts from SCM

Complex pipelines would be cumbersome to write and maintain if you could only do
that in the text area provided by the Jenkins job configuration page.

Accordingly, you also have the option of writing pipeline scripts (Jenkinsfiles)
with the editor that you use in your IDE (integrated development environment) or
SCM system, and then loading those scripts into Jenkins using the *Pipeline
Script from SCM* option enabled by the workflow-scm-step plugin, which is one of
the plugins that the Pipeline plugin depends on and automatically installs.

Loading pipeline scripts using the `checkout scm` step leverages the
idea of "pipeline as code," and lets you maintain pipelines using version
control and standalone Groovy editors.

To do this, select *Pipeline script from SCM* when defining the pipeline.

With the *Pipeline script from SCM* option selected, you do not enter any Groovy
code in the Jenkins UI; you just indicate by specifying a path where in source
code you want to retrieve the pipeline from. When you update the designated
repository, a new build is triggered, as long as your job is configured with an
SCM polling trigger.

== Writing Pipeline Scripts in the Jenkins UI

Because Pipelines are comprised of text scripts, they can be written (edited) in
the same script creation area of the Jenkins user interface where you create
them:

image::/images/pipeline/pipeline-editor.png[title="Pipeline Editor", 800]

NOTE: You determine which kind of pipeline you want to set up before writing it.

=== Using Snippet Generator

You can use the Snippet Generator tool to create syntax examples for individual
steps with which you might not be familiar, or to add relevant syntax to a step
with a long and complex configuration.

Snippet Generator is dynamically populated with a list of the steps available
for pipeline configuration. Depending on the plugins installed to your Jenkins
environment, you may see more or fewer items in the list exposed by Snippet
Generator.

To add one or more steps from Snippet Generator to your pipeline code:

. Open Snippet Generator
. Scroll to the step you want
. Click that step
. Configure the selected step, if presented with configuration options
. Click *Generate Groovy* to see a Groovy snippet that runs the step as configured
. Optionally select and configure additional steps

image::/images/pipeline/snippet-generator.png[title="Snippet Generator", 800]

When you click *Generate Groovy* after selecting a step, you see the function
name used for that step, the names of any parameters it takes (if they are not
default parameters), and the syntax used by Snippet Generator to create that
step.

You can copy and paste the generated code right into your Pipeline, or use it as
a starting point, perhaps deleting any optional parameters that you do not need.

To access information about steps marked with the help icon (question mark),
click on that icon.

== Basic Syntax for Pipeline Script

You typically add functionality to a new pipeline by performing the following tasks:

* Adding nodes
* Adding more complex logic (usually expressed as stages and steps)

To configure a pipeline you have created through the Jenkins UI, select the
pipeline and click *Configure*.

If you run Jenkins on Linux or another Unix-like operating system with a Git
repository that you want to test, for example, you can do that with syntax like
the following, substituting your own name for `jglick`:


[pipeline]
----
// Script //
node {
    git url: 'https://github.com/jglick/simple-maven-project-with-tests.git'
    def mvnHome = tool 'M3'
    sh "${mvnHome}/bin/mvn -B verify"
}
----

In Windows environments, you would use `bat` in place of `sh`, for example,
rather than:

[source, groovy]
----
sh "${mvnHome}/bin/mvn -B verify"
----

you would use:

[source, groovy]
----
bat "${mvnHome}/bin/mvn -B verify"
----

Your Groovy pipeline script can include functions, conditional tests, loops,
try/catch/finally blocks, and so on.

Sample syntax for one node in a Java environment that is using the open source
Maven build automation tool (note the definition for `mvnHome`) is shown below:


[pipeline]
----
// Script //
node('remote') {
    git url: 'https://github.com/jglick/simple-maven-project-with-tests.git'

    def mvnHome = tool 'M3' // <1>
    def v = version()

    if (v) {
      echo "Building version ${v}"
    }

    sh "${mvnHome}/bin/mvn -B -Dmaven.test.failure.ignore verify"

    archiveArtifacts artifacts: '**/target/*.jar', fingerprint: true
    junit '**/target/surefire-reports/TEST-*.xml'
}

/** Parse the pom.xml for the version number */
def version() {
  def matcher = readFile('pom.xml') =~ '<version>(.+)</version>'
  if (matcher) {
    return matcher[0][1]
  }
  return null
}
----

Pipeline Sample (graphic) key:

* `def` is a keyword to define a function (you can also give a Java type in
  place of `def` to make it look more like a Java method)
* `=~` is Groovy syntax to match text against a regular expression
* [0] looks up the first match
* [1] looks up the first (…) group within that match
* `readFile` step loads a text file from the workspace and returns its content
  (Note: Do not use `java.io.File` methods, these refer to files on the master
  where Jenkins is running, not files in the current workspace).

The tool step makes sure a tool with the given name is installed on the current
node. The script needs to know where it was installed, so the tool can be run
later. For this, you need a variable.

The `def` keyword in Groovy is the quickest way to define a new variable (with no specific type).

In the sample syntax discussed above, a variable is defined by the following expression:


[source, groovy]
----
def mvnHome = tool 'M3'
----

This ensures that 'M3' is installed somewhere accessible to Jenkins and assigns
the return value of the step (an installation path) to the `mvnHome` variable.

== Advanced Syntax for Pipeline Script

Groovy lets you omit parentheses around function arguments. The named-parameter
syntax is also a shorthand for creating a map, which in Groovy uses the syntax
`[key1: value1, key2: value2]`, so you could write:


[source, groovy]
----
git([url: 'https://github.com/joe_user/simple-maven-project-with-tests.git', branch: 'master'])
----

For convenience, when calling steps taking only one parameter (or only one
mandatory parameter), you can omit the parameter name. For example, the
following two lines are functionally equivalent:

[source, groovy]
----
sh 'echo hello' /* short form  */
sh([script: 'echo hello'])  /* long form */
----

=== Working with the Environment

Jenkins Pipeline exposes environment variables via the global variable `env`,
which is available from anywhere within a `Jenkinsfile`. The full list of
environment variables accessible from within Jenkins Pipeline is documented at
link:http://localhost:8080/pipeline-syntax/globals#env[localhost:8080/pipeline-syntax/globals#env],
assuming a Jenkins master is running on `localhost:8080`, and includes:

BUILD_ID:: The current build ID, identical to BUILD_NUMBER for builds created in Jenkins versions 1.597+
JOB_NAME:: Name of the project of this build, such as "foo" or "foo/bar".
JENKINS_URL:: Full URL of Jenkins, such as http://example.com:port/jenkins/ (NOTE: only available if Jenkins URL set in "System Configuration")




Referencing or using these environment variables can be accomplished like
accessing any key in a Groovy
link:http://groovy-lang.org/syntax.html#_maps[Map],
for example:

[pipeline]
----
// Script //
node {
    echo "Running ${env.BUILD_ID} on ${env.JENKINS_URL}"
}
----


==== Setting environment variables

Setting an environment variable within a Jenkins Pipeline can be done with the
`withEnv` step, which allows overriding specified environment variables for a
given block of Pipeline Script, for example:

[pipeline]
----
// Script //
node {
    /* .. snip .. */
    withEnv(["PATH+MAVEN=${tool 'M3'}/bin"]) {
        sh 'mvn -B verify'
    }
}
----


=== Build Parameters

If you configured your pipeline to accept parameters using the *Build with
Parameters* option, those parameters are accessible as Groovy variables of the
same name.

/////
TODO: Expand this section with more examples
/////

=== Recording Test Results and Artifacts

If there are any test failures in a given build, you want Jenkins to record
them and then proceed, rather than stopping. If you want it saved, you must
capture the `.jar` that you built. The following sample code for a node shows how
(As previously seen in examples from this guide, Maven is being used as
a build tool):

[pipeline]
----
// Script //
node {
    /* .. snip .. */
    archiveArtifacts artifacts: '**/target/*.jar', fingerprint: true
    junit '**/target/surefire-reports/TEST-*.xml'
}
----

(Older versions of Pipeline require a slightly more verbose syntax.
The “snippet generator” can be used to see the exact format.)

* If tests fail, the Pipeline is marked unstable (as denoted by a yellow ball in
  the Jenkins Web UI), and you can browse "Test Result Trend" to see the relevant history.
* You should see Last Successful Artifacts on the Pipeline's main page.
