---
layout: section
---
:notitle:
:description:
:author:
:email: jenkinsci-docs@googlegroups.com
:sectanchors:
:toc: left

= The Jenkinsfile


////
XXX: Still much reworking of this section to be done
22:00 < rtyler> then I think the other pieces (recording test results, archiving artifacts, parallel, etc) should move over into the Jenkinsfile section of the chapter
22:00 < rtyler> whatcha think bitwiseman (and hrmpw if he's floating about)
22:02 < bitwiseman> References: yeah, that make sense.
////



== Audience and Purpose

This document is intended for Jenkins users who want to leverage the power of
pipeline functionality. Extending the reach of what was learned from a "Hello
World" example in link:/doc/pipeline/[Getting Started with Pipeline], this
document explains how to use a `Jenkinsfile` to perform a simple checkout and
build for the contents of a repository.

== Creating a Jenkinsfile

A `Jenkinsfile` is a container for your pipeline (or other) script, which details
what specific steps are needed to perform a job for which you want to use
Jenkins. You create a `Jenkinsfile` with your preferred Groovy editor, or through
the configuration page on the web interface of your Jenkins instance.

Using a Groovy editor to code a `Jenkinsfile` gives you more flexibility for
building complex single or multibranch pipelines, but whether you use an editor
or the Jenkins interface does not matter if what you want to do is get familiar
with basic `Jenkinsfile` content.


. Open your Jenkins instance or Groovy editor.
. Navigate to the directory you want (it should be the root directory for your project).
. Use standard Jenkins syntax.
. Save your file.

The following example shows a basic `Jenkinsfile` made to build and test code for
a Maven project. `node` is the step that schedules tasks in the following block
to run on the machine (usually an agent) that matches the label specified in the
step argument (in this case, a node called "linux"). Code between the braces (
`{` and `}` ) is the body of the `node` step. The `checkout scm` command
indicates that this `Jenkinsfile` was created with an eye toward multibranch
support:


[source,groovy]
----
 node ('linux'){
  stage 'Build and Test'
  env.PATH = "${tool 'Maven 3'}/bin:${env.PATH}"
  checkout scm
  sh 'mvn clean package'
 }
----

In single-branch contexts, you could replace .checkout scm. with a source code
checkout step that calls a particular repository, such as:


[source,groovy]
----

git url: "https://github.com/my-organization/simple-maven-project-with-tests.git"
----

== Basic Syntax for Pipeline Script

You typically add functionality to a new pipeline by performing the following tasks:

* Adding nodes
* Adding more complex logic (usually expressed as stages and steps)

To configure a pipeline you have created through the Jenkins UI, select the
pipeline and click *Configure*.

If you run Jenkins on Linux or another Unix-like operating system with a Git
repository that you want to test, for example, you can do that with syntax like
the following, substituting your own name for `jglick`:


[pipeline]
----
// Script //
node {
    git url: 'https://github.com/jglick/simple-maven-project-with-tests.git'
    def mvnHome = tool 'M3'
    sh "${mvnHome}/bin/mvn -B verify"
}
----

In Windows environments, you would use `bat` in place of `sh`, for example,
rather than:

[source, groovy]
----
sh "${mvnHome}/bin/mvn -B verify"
----

you would use:

[source, groovy]
----
bat "${mvnHome}/bin/mvn -B verify"
----

Your Groovy pipeline script can include functions, conditional tests, loops,
try/catch/finally blocks, and so on.

Sample syntax for one node in a Java environment that is using the open source
Maven build automation tool (note the definition for `mvnHome`) is shown below:


[pipeline]
----
// Script //
node('remote') {
    git url: 'https://github.com/jglick/simple-maven-project-with-tests.git'

    def mvnHome = tool 'M3' // <1>
    def v = version()

    if (v) {
      echo "Building version ${v}"
    }

    sh "${mvnHome}/bin/mvn -B -Dmaven.test.failure.ignore verify"

    archiveArtifacts artifacts: '**/target/*.jar', fingerprint: true
    junit '**/target/surefire-reports/TEST-*.xml'
}

/** Parse the pom.xml for the version number */
def version() {
  def matcher = readFile('pom.xml') =~ '<version>(.+)</version>'
  if (matcher) {
    return matcher[0][1]
  }
  return null
}
----

Pipeline Sample (graphic) key:

* `def` is a keyword to define a function (you can also give a Java type in
  place of `def` to make it look more like a Java method)
* `=~` is Groovy syntax to match text against a regular expression
* [0] looks up the first match
* [1] looks up the first (…) group within that match
* `readFile` step loads a text file from the workspace and returns its content
  (Note: Do not use `java.io.File` methods, these refer to files on the master
  where Jenkins is running, not files in the current workspace).

The tool step makes sure a tool with the given name is installed on the current
node. The script needs to know where it was installed, so the tool can be run
later. For this, you need a variable.

The `def` keyword in Groovy is the quickest way to define a new variable (with no specific type).

In the sample syntax discussed above, a variable is defined by the following expression:


[source, groovy]
----
def mvnHome = tool 'M3'
----

This ensures that 'M3' is installed somewhere accessible to Jenkins and assigns
the return value of the step (an installation path) to the `mvnHome` variable.

== Advanced Syntax for Pipeline Script

Groovy lets you omit parentheses around function arguments. The named-parameter
syntax is also a shorthand for creating a map, which in Groovy uses the syntax
`[key1: value1, key2: value2]`, so you could write:


[source, groovy]
----
git([url: 'https://github.com/joe_user/simple-maven-project-with-tests.git', branch: 'master'])
----

For convenience, when calling steps taking only one parameter (or only one
mandatory parameter), you can omit the parameter name. For example, the
following two lines are functionally equivalent:

[source, groovy]
----
sh 'echo hello' /* short form  */
sh([script: 'echo hello'])  /* long form */
----

=== Working with the Environment

Jenkins Pipeline exposes environment variables via the global variable `env`,
which is available from anywhere within a `Jenkinsfile`. The full list of
environment variables accessible from within Jenkins Pipeline is documented at
link:http://localhost:8080/pipeline-syntax/globals#env[localhost:8080/pipeline-syntax/globals#env],
assuming a Jenkins master is running on `localhost:8080`, and includes:

BUILD_ID:: The current build ID, identical to BUILD_NUMBER for builds created in Jenkins versions 1.597+
JOB_NAME:: Name of the project of this build, such as "foo" or "foo/bar".
JENKINS_URL:: Full URL of Jenkins, such as http://example.com:port/jenkins/ (NOTE: only available if Jenkins URL set in "System Configuration")




Referencing or using these environment variables can be accomplished like
accessing any key in a Groovy
link:http://groovy-lang.org/syntax.html#_maps[Map],
for example:

[pipeline]
----
// Script //
node {
    echo "Running ${env.BUILD_ID} on ${env.JENKINS_URL}"
}
----


==== Setting environment variables

Setting an environment variable within a Jenkins Pipeline can be done with the
`withEnv` step, which allows overriding specified environment variables for a
given block of Pipeline Script, for example:

[pipeline]
----
// Script //
node {
    /* .. snip .. */
    withEnv(["PATH+MAVEN=${tool 'M3'}/bin"]) {
        sh 'mvn -B verify'
    }
}
----


=== Build Parameters

If you configured your pipeline to accept parameters using the *Build with
Parameters* option, those parameters are accessible as Groovy variables of the
same name.

/////
TODO: Expand this section with more examples
/////

=== Recording Test Results and Artifacts

If there are any test failures in a given build, you want Jenkins to record
them and then proceed, rather than stopping. If you want it saved, you must
capture the `.jar` that you built. The following sample code for a node shows how
(As previously seen in examples from this guide, Maven is being used as
a build tool):

[pipeline]
----
// Script //
node {
    /* .. snip .. */
    archiveArtifacts artifacts: '**/target/*.jar', fingerprint: true
    junit '**/target/surefire-reports/TEST-*.xml'
}
----

(Older versions of Pipeline require a slightly more verbose syntax.
The “snippet generator” can be used to see the exact format.)

* If tests fail, the Pipeline is marked unstable (as denoted by a yellow ball in
  the Jenkins Web UI), and you can browse "Test Result Trend" to see the relevant history.
* You should see Last Successful Artifacts on the Pipeline's main page.


== Making Pull Requests

A pull request notifies the person responsible for maintaining a Jenkins
repository that you have a change or change set that you want to see merged into
the main branch associated with that repository. Each individual change is
called a "commit."

You make pull requests from a command line, or by selecting the appropriately
labeled button (typically "Pull" or "Create Pull Request") in the interface for
your source code management system.

A pull request to a repository included in or monitored by an Organization
Folder can be used to automatically execute a multibranch pipeline build.


== Using Organization Folders

Organization folders enable Jenkins to automatically detect and include any new
repositories within them as resources.

When you create a new repository (as might be the case for a new project), that
repository has a `Jenkinsfile`. If you also configure one or more organization
folders, Jenkins automatically detects any repository in an organization folder,
scans the contents of that repository at either default or configurable
intervals, and creates a Multibranch Pipeline project for what it finds in the
scan. An organization folder functions as a "parent," and any item within it is
treated as a "child" of that parent.

Organization folders alleviate the need to manually create projects for new
repositories. When you use organization folders, Jenkins views your repositories
as a hierarchy, and each repository (organization folder) may optionally have
child elements such as branches or pull requests.


To create Organization folders:

. Open Jenkins in your web browser.
. Go to: New Item → GitHub Organization or New Item → Bitbucket Team.
. Follow the configuration steps, making sure to specify appropriate scan
  credentials and a specific owner for the GitHub Organization or Bitbucket Team
  name.
. Set build triggers by selecting the checkbox associated with the trigger type
  you want. Folder scans and the pipeline builds associated with those scans can
  be initiated by command scripts or performed at defined intervals. They can also
  triggered by project promotion or changes to the images in a monitored Docker
  hub.
. Decide whether to automatically remove or retain unused items. "Orphaned Item
  Strategy" fields in the configuration interface let you specify how many days to
  keep old items, and how many old items to keep. If you enter no values in these
  fields, unused items are removed by default.

While configuring organization folders, you can set the following options:

* Repository name pattern - a regular expression to specify which repositories are included in scans
* API endpoint - an alternate API endpoint to use a self-hosted GitHub Enterprise
* Checkout credentials - alternate credentials to use when checking out (cloning) code

Multibranch Pipeline projects and Organization Folders are examples of
"computed folder" functionality. In Multibranch Pipeline projects, computation
creates child items for eligible branches. In Organization folders, computation
populates child items as individual Multibranch Pipelines for scanned
repositories.

Select the "Folder Computation" section of your Jenkins interface to see the
duration (in seconds) and result (success or failure) of computation operations,
or to access a Folder Computation Log that provides more detail about this
activity.

== Basic Checkout and Build

Checkout and build command examples are shown in the code example used by the
introduction above. Examples shown assume that Jenkins is running on Linux or
another Unix-like operating system.

If your Jenkins server or agent is running on Windows, you are less likely to be
using the Bourne shell (`sh`) or
link:http://www.computerhope.com/unix/ubash.htm[Bourne-Again shell] (`bash`) as
a command language interpreter for starting software builds. In Windows
environments, use `bat` in place of `sh`, and backslashes (`\`) rather than
slashes as file separators in pathnames.
