---
layout: documentation
title: Pipeline
---
:notitle:
:description:
:author:
:email: jenkinsci-users@googlegroups.com
:sectanchors:
:imagesdir: /doc/book/resources
:toc:

////
NOTE: The sections are ordered from simpler to progressively more complex
subjects.  The earlier sections are intended for those new to pipeline or
unfamiliar with its latest features.  The later sections with discuss
expert-level considerations and corner-cases.

This chapter functions as a continuation of "Getting Started with Jenkins" and
"Using Jenkins" , but the format will be slightly different - see the
description above.  The first sections should lead users through the basics of
pipeline, and later sections can switch to feature reference for experienced
users. All sections should still be written and ordered to only assume
knowledge from "Getting Started", "Using Jenkins", or from previous sections in
this chapter.
////

= Pipeline

This chapter will cover all aspects of Jenkins Pipeline, from running pipeline jobs
to writing your own pipeline code, and even extending Pipeline.

This chapter is intended to be used by Jenkins users of all skill levels,
but beginners may need to refer to some sections of "<<using#,Using Jenkins>>"
to understand some topics covered in this chapter.

If you are not yet familiar with basic Jenkins terminology and features, start with
<<getting-started#,Getting Started with Jenkins>>.

[[overview]]
== What is Pipeline?

Jenkins Pipeline is a suite of plugins which supports implementing and
integrating continuous delivery pipelines into Jenkins. Pipeline provides an
extensible set of tools for modeling simple-to-complex delivery pipelines "as
code" via the <<syntax,Pipeline DSL>>.
footnoteref:[dsl,link:https://en.wikipedia.org/wiki/Domain-specific_language[Domain-Specific Language]]

Typically, this "Pipeline as Code" would be written to  a <<Jenkinsfile,`Jenkinsfile`>> and
checked into a project's source control repository, for example:

[pipeline]
----
// Declarative //
pipeline {
  agent { // <1>
    label ''
  }

  stages{
    stage('Build') { // <2>
      steps { // <3>
        sh 'make' // <4>
      }
    }
    stage('Test'){
      steps {
        sh 'make check'
        junit 'reports/**/*.xml' // <5>
      }
    }
    stage('Deploy') {
        steps {
          sh 'make publish'
        }
    }
  }
}
// Script //
node {
    stage('Build') {
        sh 'make'
    }

    stage('Test') {
        sh 'make check'
        junit 'reports/**/*.xml'
    }

    stage('Deploy') {
        sh 'make publish'
    }
}
----
<1> <<agent,`agent`>> indicates that Jenkins should allocate an executor and workspace for
this part of the Pipeline.
<2> <<stage,`stage`>> describes a stage of this Pipeline.
<3> <<steps, `steps`>> describes the steps to be run in this `stage`
<4> `sh` executes the given shell command
<5> `junit` is a Pipeline <<step,step>> provided by the
link:https://plugins.jenkins.io/junit[JUnit plugin]
for aggregating test reports.

[[why]]
== Why Pipeline?

Jenkins is, fundamentally, an automation engine which supports a number of
automation patterns. Pipeline adds a powerful set of automation tools onto
Jenkins, supporting use cases that span from simple continuous integration to
comprehensive continuous delivery pipelines. By modeling a series of related
tasks, users can take advantage of the many features of Pipeline:

* *Code*: Pipelines are implemented in code and typically checked into
  source control, giving teams the ability to edit, review, and iterate upon
  their delivery pipeline.
* *Durable*: Pipelines can survive both planned and unplanned restarts of the
  Jenkins master.
* *Pausable*: Pipelines can optionally stop and wait for human input or approval
  before continuing the Pipeline run.
* *Versatile*: Pipelines support complex real-world continuous delivery
  requirements, including the ability to fork/join, loop, and perform work in
  parallel.
* *Extensible*: The Pipeline plugin supports custom extensions to its DSL
  footnoteref:[dsl]
  and multiple options for integration with other plugins.


While Jenkins has always allowed rudimentary forms of chaining Freestyle Jobs
together to perform sequential tasks,
footnote:[Additional plugins have been used to implement complex behaviors
utilizing Freestyle Jobs such as the Copy Artifact, Parameterized Trigger,
and Promoted Builds plugins]
Pipeline makes this concept a first-class citizen in Jenkins.

Building on the core Jenkins value of extensibility, Pipeline is also
extensible both by users with <<pipeline/shared-libraries#,Pipeline Shared Libraries>>
and by plugin developers.
footnoteref:[ghof,link:https://plugins.jenkins.io/github-organization-folder[GitHub
Organization Folder plugin]]


The flowchart below is an example of one continuous delivery scenario easily
modeled in Jenkins Pipeline:

image::pipeline/realworld-pipeline-flow.png[title="Pipeline Flow", 800]

[[syntax]]
== Scripted Pipeline Syntax and Declarative Pipeline Syntax

When Pipeline was first conceived it was natural to begin with Groovy as the
foundation. Jenkins already had an embedded Groovy scripting engine with a console
to interact with all parts of Jenkins and Groovy is a great language for creating
a custom Domain-Specific Language (DSL). The
link:https://plugins.jenkins.io/job-dsl[Job-DSL],
plugin for Jenkins was also written in Groovy. This plugin lets you automate the
creation and editing of any job in Jenkins, including Pipelines.

Pipeline initially introduced key pipeline-specific concepts such as `node`,
`stage`, `parallel`, and extension points to allow plugins to add other steps
to the DSL but, otherwise didn't restrict the use of Groovy. This original syntax
for creating Pipelines is now referred to as "Scripted Pipeline" and includes
full programmatic control to allow scripting continuous delivery pipelines in Groovy.
This givesPipeline creators tremendous flexibility in defining a pipeline and allows it to
be extended via <<shared-libraries#, Shared Libraries>> or plugins.


CAUTION: Due to the need to serialize all variables for durability some Groovy
idioms are not fully supported yet. See
https://issues.jenkins-ci.org/browse/JENKINS-27421[JENKINS-27421]
and
https://issues.jenkins-ci.org/browse/JENKINS-26481[JENKINS-26481]
for more information.

Writing Pipelines with Scripted Pipeline syntax, however, does require at least
some proficiency with Groovy. Requiring all team members that touch the application's
Pipeline to understand Groovy limits the ability for full-participation in
code-review, audits, and editing of the Pipeline as part of the application code.
Enter "Declarative Pipeline" syntax.

Declarative Pipeline syntax was created to extend Pipeline to users of all experience
levels and complement Scripted Pipeline syntax. As the name implies, it is intended
to enable declarative programming
footnoteref:[declarative, link:https://en.wikipedia.org/wiki/Declarative_programming[Declarative Programming]]
for defining Pipelines as opposed to the imperative programming
footnoteref:[imperative, link:https://en.wikipedia.org/wiki/Imperative_programming[Imperative Programming]]
provided by Scripted Pipeline. While it is still a DSL written
on top of Groovy, Declarative Pipeline is a limited to a pre-defined structure
that is much more specific to continuous delivery. This allows all stakeholders
to help create, edit, review, and audit the application's Pipeline.

Scripted Pipeline and Declarative Pipeline both use the same underlying Pipeline
execution engine and both are fully-supported. You can use whichever you prefer
in any of your Pipelines and even combine them when needed. All examples in this handbook will show
both a Declarative Pipeline version and Scripted Pipeline version for your reference.

[[terms]]
== Pipeline Terms

[[step]]
Step::
    A single task; fundamentally steps tell Jenkins _what_ to do. For example,
    to execute the shell command `make` use the `sh` step: `sh 'make'`.
    When a plugin extends the Pipeline DSL, that typically means the plugin has
    implemented a new _step_.

[[node]]
Node::
    Most _work_ a Pipeline performs is done in the context of one or more
    declared `node` steps. Confining the work inside of a node step does two
    things:
    . Schedules the steps contained within the block to run by adding an item
      to the Jenkins queue. As soon as an executor is free on a node, the
      steps will run.
    . Creates a workspace (a directory specific to that particular
      Pipeline) where work can be done on files checked out from source control.

CAUTION: Depending on your Jenkins configuration, some workspaces may not get
automatically cleaned up after a period of inactivity. See tickets and
discussion linked from
https://issues.jenkins-ci.org/browse/JENKINS-2111[JENKINS-2111]
for more information.

[[stage]]
Stage::
    `stage` is a step for defining a conceptually distinct subset of the
    entire Pipeline, for example: "Build", "Test", and "Deploy", which is used by many
    plugins to visualize or present Jenkins Pipeline status/progress.
    footnoteref:[blueocean,link:/projects/blueocean[Blue Ocean], link:https://wiki.jenkins-ci.org/display/JENKINS/Pipeline+Stage+View+Plugin[Pipeline Stage View plugin]]
